@Test
    public void testSaveRealmDatasources_ShouldThrowException_WhenDuplicateEntryExists() {
        // Given
        String schemaId = "testSchemaId";
        String realmId = "testRealmId";
        RealmDatasourceModel realmDatasource = new RealmDatasourceModel();
        realmDatasource.setId(realmId);

        List<RealmDatasourceModel> realmDatasources = List.of(realmDatasource);
        List<CustomerDatasourceDetails> existingDetailsList = new ArrayList<>();
        existingDetailsList.add(new CustomerDatasourceDetails());

        // Mock the existence check for schemaId
        when(productSchemaMappingRepository.existsBySchemaId(anyString())).thenReturn(true);

        // Mock the check for existing realmId and schemaId combination
        when(customerDatasourceDetailsRepository.findBySchemaIdAndRealmId(anyString(), anyString()))
                .thenReturn(existingDetailsList);

        // When / Then
        assertThatThrownBy(() -> productSchemaService.saveRealmDatasources(schemaId, realmDatasources))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Duplicate entry found for schemaId: " + schemaId + " and one of the realmIds");

        // Verify interactions
        verify(productSchemaMappingRepository, times(1)).existsBySchemaId(anyString());
        verify(customerDatasourceDetailsRepository, times(1)).findBySchemaIdAndRealmId(anyString(), anyString());
    }

    @Test
    public void testSaveRealmDatasources_ShouldSaveSuccessfully_WhenNoDuplicateEntryExists() {
        // Given
        String schemaId = "testSchemaId";
        String realmId = "testRealmId";
        RealmDatasourceModel realmDatasource = new RealmDatasourceModel();
        realmDatasource.setId(realmId);

        List<RealmDatasourceModel> realmDatasources = List.of(realmDatasource);
        List<CustomerDatasourceDetails> emptyDetailsList = new ArrayList<>();
        CustomerDatasourceDetails customerDatasourceDetails = new CustomerDatasourceDetails();
        customerDatasourceDetails.setSchemaId(schemaId);

        // Mock the existence check for schemaId
        when(productSchemaMappingRepository.existsBySchemaId(anyString())).thenReturn(true);

        // Mock the check for existing realmId and schemaId combination
        when(customerDatasourceDetailsRepository.findBySchemaIdAndRealmId(anyString(), anyString()))
                .thenReturn(emptyDetailsList);

        // Mock the save operation
        when(customerDatasourceDetailsRepository.save(any(CustomerDatasourceDetails.class)))
                .thenReturn(customerDatasourceDetails);

        // Mock the mapping from DTO to entity and vice versa
        when(customerDatasourceDetailsMapper.toEntity(any(RealmDatasourceModel.class)))
                .thenReturn(customerDatasourceDetails);
        when(customerDatasourceDetailsMapper.toDTO(any(CustomerDatasourceDetails.class)))
                .thenReturn(realmDatasource);

        // When
        RealmDatasourcesModel response = productSchemaService.saveRealmDatasources(schemaId, realmDatasources);

        // Then
        assertThat(response).isNotNull();
        assertThat(response.getRealmDatasources()).isNotEmpty();
        assertThat(response.getRealmDatasources().get(0).getId()).isEqualTo(realmId);

        // Verify interactions
        verify(productSchemaMappingRepository, times(1)).existsBySchemaId(anyString());
        verify(customerDatasourceDetailsRepository, times(1)).findBySchemaIdAndRealmId(anyString(), anyString());
        verify(customerDatasourceDetailsRepository, times(1)).save(any(CustomerDatasourceDetails.class));
    }